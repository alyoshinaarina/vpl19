# Проект Аллы Чудиновой и Анастасии Козловой
### Задача: написать код, благодаря которому программа сможет определять часть речи слова. ### 
**Пользователь вводит слово в начальной форме. Программа обрабатывает слово, обращая внимание на «абстрактный конец» слова, который состоит либо из аффиксов (например, «чик») или сочетания аффиксов, которые присущи той или иной части речи (например, «янный»).**

Для решения данной задачи мы, во-первых, создаем два словаря: POS (parts of speech) и others.

Словарь __POS__ нужен для определения тех частей речи, которые представляют собой (почти) бесконечный множество, для идентифицирования которых нужно найти закономерность. Словарь POS содержит в себе ключи - названия частей речи - и значения - списки с "абстрактными концами" слов, представляющих собой все аффиксы русского языка или (т.к. зависит от части речи слова) все аффиксы в сочетаниями со всеми флексиями начальной формы( хотя у нас есть учёт рода и числа).

Словарь __others__ нужен для определения служебных частей речи, а так же тех частей речи, к которым относятся относительно малое число слов: союзы, частицы, предлоги, местоимения и некоторые числительные.Словарь others содержит в себе ключи - названия частей речи - и значения - списки со словами.

Далее пишем непосредственно функцию *find_POS*. В ней мы создали пустой список *res* (значит result), в который программа будет с помощью *append* добавлять длину "абстрактного конца"(для служебных частей речи и иного из __others__ всегда будет равно 1) , сам "абстрактный конец" и название части речи непосредственно. После это будет выведено пользователю при помощи print('Ваше слово скорее всего является - *{}'.format(max(res)[2]))* и *print*('Вот, что нашла программа - *{}'.format(res))*.

Программа с помощью ветвления *if-else-elif* сначала проверяет, соответствует ли введенное пользователем слово слову из значений словаря __others__. Если да, то программа выводит сообщение о том, что введенное слово скорее всего является частью речи из __others__ (какой именно частью речи - зависит от слова).

Если введенное слово не соответствует ничему и словаря __others__, то программа проверяет, соответстует ли "абстрактный конец" введенного слово какому-либо "абстрактному концу" из значений в словаре __POS__.

Мы решили, что будет лучше "пройтись" по слову с конца, используя цикл for. Программа будет проверять символы введенного слова с конца с шагом -1 до 6 буквы с конца *(for index in range(-1, -7, -1): )* Именно до шестой буквы с конца, потому что самый длинный "абстрактный конец слова" содержит 6 букв. Если программа находит совпадение, то она показывает результат и с помощью *append* добавляет в список *re*s длину "конца", сам "абстрактный конец" и название части речи. Если совпадений несколько(например, есть черты и причастия, и прилагательного, но программа в ответе-предположении отображает ту часть речи, чьих "признаков" больше, но вместе с тем и показывает, конец какой еще части речи она нашла

Также нам хотелось попробовать недавно изученный *try-except*, чтобы программа, если не найдет совпадений, "не сломалась".


	try:
        
  	print('Ваше слово скорее всего является - {}'.format(max(res)[2]))
        print('Вот, что нашла программа - {}'.format(res))
    except ValueError as error:
        print('Для слова не удалось найти ни одного аффикса в базе данных')
        
"Взаимодействие" с пользователем реализуем с помощью цикла *while*. Программа просит ввести слово, а после ввода "спрашивает", хочет ли пользователь ввести что-то еще. Далее всё зависит от ответа пользователя.

*P.S. Наша программа вовсе не совершенна, в основном из-за невозможности определять слова только по окончаниям. Тогда возможна некая "омонимия". Например, программа не сможет отличить слова "молоко" и "далеко" и отнесет и то, и другое к наречиям. Та же ситуация и с причастиями и прилагательными. Скорее всего, программа может "подкинуть" причастие в семью имен прилагательных. Мы тут бессильны, но надеемся, что когда-нибудь сможем решить эту проблему и улучшить код.* :):):)
.